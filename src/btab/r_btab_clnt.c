/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "r_btab.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

rtab *
btab_new_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_NEW, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_init_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_INIT, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_clear_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_CLEAR, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_delete_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_DELETE, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_open_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_OPEN, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_close_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_CLOSE, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_rewind_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_REWIND, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_get_next_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_GET_NEXT, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_get_previous_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_GET_PREVIOUS, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_get_at_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_GET_AT, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_put_at_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_PUT_AT, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

rtab *
btab_append_1(rtab *argp, CLIENT *clnt)
{
	static rtab clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_APPEND, xdr_rtab, argp, xdr_rtab, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

short *
btab_is_empty_1(rtab *argp, CLIENT *clnt)
{
	static short clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_IS_EMPTY, xdr_rtab, argp, xdr_short, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

short *
btab_is_not_empty_1(rtab *argp, CLIENT *clnt)
{
	static short clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, BTAB_IS_NOT_EMPTY, xdr_rtab, argp, xdr_short, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
